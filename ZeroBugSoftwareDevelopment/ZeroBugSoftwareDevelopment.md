# Zero-Bug Software Development
이 글은 프로그래밍에 대한 이야기가 아니라 소프트웨어가 만들어지는 전체 과정에 대한 이야기입니다.
대상 독자는 개발자 뿐만 아니라 요구사항을 스펙으로 만드는 기획팀,  QA팀, DevOps팀, 프로젝트 매니저(PM), 프로덕트 오너(PO)등 모든 R&D 조직원입니다.

## 0. Preface
### 더 많은 테스트를 더 일찍, 더 빠르게
2022년 SSTC 서울 국제 소프트웨어 테스팅 컨퍼런스의 주제가 "더 많은 테스트를 더 일찍, 더 빠르게"였는데 이 글에서 말하고 싶은 주제도 이와 동일하다.

버그를 줄이는 방법은 **더 많은 테스트**를 하는 것이다.
아무도 몰래 버그가 스며든 후부터(t1) 버그가 발견되기 까지(t2)의 시간 간격(t2 - t1)이 길면 길수록 비용이 많이들기 때문에 **더 일찍** 테스트 해야하고 테스트 수행 시간이 오래 걸리면 오래 걸릴 수록 생산성이 낮아지므로 **더 빠르게** 테스트가 수행되어 결과를 알 수 있어야한다.

혹자는 이렇게 반문할 것이다.
> "애초에 버그를 만들지 않는 방향으로 가야하는게 아니냐고"

2022년 현재 런타임 버그를 모두 잡아내는 컴파일러나 AI는 존재하지 않기 때문에 이론적으로 모든 경우의 수를 테스트하는 것이야 말로 모든 버그를 잡아내는 방법이다. 
테스트하지 않은 시나리오에는 버그가 숨어있을 가능성이 있다는 것이다.

### Zero-Bug
Zero-bug는 버그가 전혀 없다는 의미가 아니라 버그가 거의 없다는 의미로 사용된다.
세상에 버그가 단 한 개도 존재하지 않는 상용 소프트웨어는 존재하지 않을 수도 있다.
그럼에도 불구하고 Zero-Bug는 software industry의 최종 목표이기 때문에 지금도 많은 선구자들이 버그 없는 소프트웨어를 개발하기 위해 연구하고 있다.

### 돌도끼에서 망치로
돌도끼에서 망치로 진화한 것 만큼 근래 20년 동안 소프트웨어 개발 방법에 많은 개선이 이루어졌다.
20년전 waterful model로 시작해서 V model을 거쳐 지금은 Agile 방법이 대세를 이루고 있다.
미래에는 컴파일 시점에 모든 런타임 버그를 발견하는 새로운 프로그래밍 언어가 출시되어 테스트가 불필요 하는 날이 올 수도 있고, 인간 대신 AI가 버그 없는 완벽한 코드를 생산하는 날이 올 수도 있고, Test AI가 알파고 바둑처럼 모든 경우의 수를 시나리오로 만들어서 자동으로 테스트하는 날이 올 수도 있다.
그러나 test.ai가 발전하고 있지만 아직은 자율주행처럼 시기상조이다.

### 선구자
TDD를 처음 제안한 Kent Back, 이를 이어받아 개선시킨 Martin Folwer와 마이클 패더스등은 소프트웨어 개발 방법론에 크게 기여한 선구자들이다. 이들의 노고에 감사의 말을 전하고 싶다.

### Agile
여기서 소개하는 방법들은 Agile의 핵심 실천 방법들로서 Agile로 개발하면 TDD 방식으로 생산된 unit test code가 CI(Continueos Integration)와 CD(Continues Deployment)의 입력으로 들어가서 test automation 방식으로 매일 테스트를 통과하는 것을 뜻한다.
Agile은 여기에서 소개하는 핵심 실천 방법보다 더 광범위하기 때문에 여기에서는 Agile을 소개하는 방식으로 이야기하지 않고 Zero-bug 소프트웨어를 개발하기 위해 어떻게 해야하는지에 초점을 맞출 것이다.

### 특허 없는 기술
선구자들이 제안한 방법에는 특허가 없고 이미 많은 빅테크 기업에서 사용하고 있고 그 효과가 검증되었기 때문에 우리는 감사한 마음으로 가져다 사용하면 된다.
물론 그것을 제대로 이해하고 개인의 습관과 조직 문화 및 시스템을 바꾸는 일은 뼈를 깍는 노력이 수반되지만 일단 익숙해지기만하면 조직에서 만들어내는 코드 퀄리티는 수공예 방식에서 3D 프린터로 찍어내는 것 만큼 향상될 것이다.

## 1. Human Errors
### 개발자
수천, 수만 라인을 코딩하면서 버그 한 개 없는 소프트웨어를 만들 수 있는 프로그래머가 있을까?
프로그래밍 중 버그가 생기는 일은 자연스러운 일이다.
기업에서 천재적인 프로그래머를 스카우트하면 버그 없는 소프트웨어를 개발할 수 있을까?
인간은 실수하는 동물이기 때문에 프로그래밍 중에 버그는 생길 수 밖에 없다.
실수가 아니더라도 개발자가 인지하지 못한 로직의 흐름이나 예측하기 어려운 dead lock, 고객의 특이한 실행 환경 때문에 개발 과정에서 버그를 발견하지 못하고 QA팀에 넘기게 된다.

**하인리히의 법칙** 
> 대형 사고가 발생하기 전에 같은 원인으로 수십 차례의 경미한 사고와 수백 번의 징후가 반드시 나타난다는 것을 말한다.

하인리히의 법칙에서 보듯이 참사가 일어나기전까지 버그를 발견하여 고칠 수 있는 기회를 여러번 노쳤을 것이다. 가장 먼저 놓친 기회는 무엇이었을까?
코드 변경 후 처음 코드가 실행되었을 때 개발자는 여러가지 테스트를 해보면서 버그를 발견할 수 있었다. 이 첫번째 기회를 놓친 것이다.

### QA
비단 개발자에게만 책임이 있을까?
버그가 고객에게서 처음 발견되면 배포를 승인한 QA팀도 책임에서 자유롭지는 못할 것이다.
QA팀에서 더 꼼꼼하게 테스트하고, 더 많은 test cases를 테스트하고, 더 자주 테스트한다면 zero-bug를 달성할 수 있을까?
실수가 줄어서 버그가 줄어들겠지만 몇 달 뒤 집중력을 잃으면 말짱 도루묵이다.
개발자와 테스터의 실수를 제거하거나 먼저 발견할 수 있는 방법은 없을까?

### 매뉴얼 테스트의 종말
사람이 손으로 클릭하는 매뉴얼 테스트는 골방 뒤안길로 가야한다.
그러면 테스터가 필요하지 않다는 말인가? 그렇지 않다.
대부분의 테스트는 automation test로 대체해야하고 QA팀은 탐험적인 테스트(explorer test)에 집중해야 한다. 탐험적인 테스트의 목적은 버그 발견 뿐만 아니라 생각하지 못했던 특이한 환경에 대한 테스트 시나리오를 발견하는 것이다.
그리고 이를 자동화 테스트 케이스로 추가하는 일을 반복하면서 퀄리티와 테스트 커버리지를 올리는 것이다.
어제 통과했던 수천, 수만건의 테스트 케이스를 오늘도 처음부터 실행시킬 수 있도록 시스템을 만들고 고품질을 유지하도록 관리하는 일이다.
어제 100% inocent 했던 모듈이지만 오늘 수십건의 커밋이 일어나면 0% 부터 다시 시작해야한다.
어제 통과한 테스트는 의미가 없고 다시 수천건의 테스트 케이스 통과해야만 한다.

이렇듯 매뉴얼 테스트로는 human errors를 제거할 수 없기 때문에 컴퓨터에게 테스트를 시키는 방식으로 진화해왔다.
인간이 공장 생산 라인을 자동화하도록 설계한 후 로봇이 조립/생산하는 것과 비슷하다.
이렇게 컴퓨터가 테스트를 수행하면 매일 수천 수만건의 테스트 케이스가 자동으로 검증되기 때문에 더 많은 테스트를 더 빠르고 더 일찍, 정확하게 테스트할 수 있다.

## 2. 버그가 유저에게 전달되는 이유
> 버그 없는 소프트웨어를 개발하기 위해서는 모든 시나리오에 대해서 코드로 검증되어야한다.

개발자는 코드를 추가한 후 성공하는 로직 위주로 테스트하고 문제가 없으면 안도하는 경향이 있다. 많은 버그와 싸워 이겼기 때문이다.
성공하는 테스트 케이스에 문제가 없는 것을 확인한 후 QA팀에 모듈을 넘긴다.
운나쁘게 QA에서 버그를 발견하지 못하면 사용자가 처음 버그를 발견한다.

이렇듯 배포하기 전에 다양한 시나리오에 대한 테스트를 통과해야한다.
성공하는 케이스 뿐만 아니라 실패하는 케이스와 예외적인 케이스, 스트레스 케이스,
그리고 다양한 하드웨어, 네트워크 환경, 데이터베이스에 대한 테스트를 통과한 모듈한 모듈만이 배포될 수 있다.

## 3. Unittest
### 매뉴얼 테스트의 한계
매번 마우스로 클릭하거나 키보드를 두드리는 테스트를 매뉴얼(수작업) 테스트라고 한다.
사람이 수행하는 매뉴얼 테스트에는 많은 한계점이 존재한다.
인간에게 반복적인 작업은 지루하고 실수가 포함된다.
그러나 컴퓨터는 수 십만번 반복시켜도 실수하지 않으며 100% 정확하다.

### 모든 코드는 테스트되어야 한다
모든 코드는 테스트되어야한다.

### 코드가 변경되면 도자기는 깨졌다
어제까지 모든 기능이 잘 동작한 소프트웨어라 하더라도 
코드가 커밋되는 순간 
매일 변하는 Test Coverage

**그렇다면 왜 지금까지 테스트를 컴퓨터에게 시키지 않았을까?**
다양한 이유가 있겠지만
방법을 몰랐거나, 그러한 툴이 없었거나
테스트 코드 작성이 더 오래걸린다고 생각해서 손으로 빨리 테스트했을 수도 있고
UI 테스트는 컴퓨터가 테스트할 수 없는 영역이라고 생각했을 수도 있다.
부분적으로는 테스트 코드를 만들어 사용한 사람도 있을 것이다.

## 4. The Cost of Bug Fix
심지어 아무도 버그가 주입된지도 모른채 몇 년 후 사용자로부터 버그가 보고되는 경우도 있다.

2022-11-01